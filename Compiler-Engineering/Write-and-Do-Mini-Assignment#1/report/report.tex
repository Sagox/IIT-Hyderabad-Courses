% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------
 
\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=blue
}
\begin{document}
\title{Write-and-Do-Mini-Assignment\#1: SCeV in LLVM}
\author{Sagar Jain\\CS17BTECH11034}
\maketitle

\section*{Introduction}
SCeV stands for \textbf{Scalar Evolution}. Scalar Evolution is essentially a technique to express how the value of a  \textbf{\textit{scalar}} variable changes (\textbf{\textit{evolves}}) over iterations of a loop. Scalar evolution as a technique is immensely powerful, being able to express, co-relate(different variables) and simplify complex changes that occur through a loop. These properties have made SCeV a very useful analysis for optimisations in compilers.
\subsection*{SCeV in LLVM}
The implementation of SCeV in LLVM is limited to those properties that can be used most readily by optimisers, so not everything that is theoretically possible using SCeV is used in LLVM.\\
Scalar Evolution in LLVM is actually implemented as an \textit{\textbf{analysis pass}} which does not really lead to any transformation of the module but provides valuable information in the form of \textbf{\textit{loop trip counter}}, {recurrence triplets} for variables, etc. It can be used with opt in the following way:\\\\
\texttt{opt -analyze -scalar-evolution <filename>}\\\\
There are several loop transformations that use this information provided by scalar evolution to optimise the loop, for example: \textbf{Induction Variable Simplify} i.e. \texttt{indvars}, \textbf{Loop strength reduction} i.e. \texttt{loop-reduce}, etc.\\

Induction variables are broadly classified into two types:\\
\begin{enumerate}
\item Basic Induction Variable (BIV): Which increase or decrease by a constant on each iteration of the loop.
\item Generalized Induction Variable (GIV): More complex updates, may even depend on ther IVs.
\end{enumerate}

The recurrence relation of any IV can be represented as a 3-tuple \{a, b, c\}, where a is the initial value, b categorises the type of operation and c is the value that the operand takes. Chaining of recurrences to create new recurrences is also allowed. The entire mathematical formalism of SCeV is illustrated in some detail at \href{http://llvm.org/devmtg/2018-04/slides/Absar-ScalarEvolution.pdf}{http://llvm.org/devmtg/2018-04/slides/Absar-ScalarEvolution.pdf}

\section*{Observations on usage of SCeV in LLVM}

The following are a few points to note before trying to fiddle with \texttt{-scalar-evolution}.
\begin{itemize}
\item Optimisations must to be run on IR files.
\item If we use clang -emit-llvm $\langle$filename$\rangle$ -S, we get a .ll file but optimisations will not work on it since by default the attribute \texttt{optnone} is added to functions which do not allow optimisations to run on them.
\item We can run clang with the following options to avoid the addition of \texttt{optnone attribute.}\\
\texttt{clang -O0 -Xclang -disable-O0-optnone -emit-llvm $\langle$filename$\rangle$ -S}
\item Trying to run scalar evolution on the output file of the above program also does not yield results, this is because most optimisation and analysis passes require the IR to be in pure SSA but the IR generated by us can even have loads and stores, to get around this we should first convert into SSA by using \texttt{opt -mem2reg $\langle$filename$\rangle$ -S}.
\item Now, we can use \texttt{ opt -analyze -scalar-evolution $\langle$filename$\rangle$} to get the desired output.
\end{itemize}
\subsubsection*{Basic Induction Variable}
A typical loop counter would have a SCeV analysis similar to the following:\\\\
\texttt{ \%inc = add nsw i32 \%i.0, 1\\
  -->  \{1,+,1\}<nuw><\%for.cond> U: [1,-2147483647) S: [1,-2147483647)}\\\\
We can see that we have the recurrence tuple, signed and unsigned range and other information present for the instruction. Similarly, any instruction which is \textbf{\textit{SCeVable}} has its SCeV values printed.
\end{document}