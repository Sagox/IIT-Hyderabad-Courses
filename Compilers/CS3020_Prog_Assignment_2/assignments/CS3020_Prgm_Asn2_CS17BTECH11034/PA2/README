README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should contain the following files:

 Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [cool root]/src/PA2/lextest.cc
 mycoolc         -> [cool root]/PA2/mycoolc
 stringtab.cc    -> [cool root]/PA2/stringtab.cc
 utilities.cc    -> [cool root]/PA2/utilities.cc
 handle_flags.cc -> [cool root]/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[cool root]/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the gmake
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------

Defined DIGIT as [0-9] as it is a commonly used class.

***************************************************************************************************************
From the Manual: Integers are non-empty strings of digits 0-9.						      
***************************************************************************************************************

Therefore I have writtern integers as DIGIT+.

***************************************************************************************************************
From the Manual: Any characters between two dashes "--" and the next newline								  
(or EOF, if there is no next newline) are treated as comments.												  
***************************************************************************************************************

This is directly implemented as --.* because . represents any charcter except the
newline.

***************************************************************************************************************
From the Manual: Comments may also be written by enclosing													  
text in (∗ ... ∗). The latter form of comment may be nested.												  	
***************************************************************************************************************

For these types of comments we use start conditions.
We also maintain a counter for how deep we are into the nested comments,
since the comments need to be balanced, also helps catch unmatched '*)'.
While the count is greater than 0, we ignore all characters except the newline
character, when we see it, we increase the line number.

***************************************************************************************************************
From the Manual: 																							  *			
The keywords of cool are: class, else, false, fi, if, in, inherits, isvoid, let, loop, pool, then, while,	  
case, esac, new, of, not, true. Except for the constants true and false, keywords are case insensitive. 	  
To conform to the rules for other objects, the first letter of true and false must be lowercase; the trailing 
letters may be upper or lower case.																			  
***************************************************************************************************************

We use -i to make the keywords case insensitive. For true and false we just list down all the possibilities.

***************************************************************************************************************
From the Manual:																							  
Type identifiers begin with a capital letter; object identifiers											  
begin with a lower case letter.																			   	  
***************************************************************************************************************

We use our definitions of uppercase letters, lowercase letters and chars to define the regex for the above.

***************************************************************************************************************
The list of operators is obtained from figure 1 on Page 17 of the cool manual.                                
***************************************************************************************************************

The operators are checked for directly as "<operator>" and returned as a char, the multicharacter operators are
returned with a name.

******************************************************************************************************************
Strings are enclosed in a pair of double quotes, except b,t,n,f all other escaped characters of the form \c den- 
ote c itself. A non escaped newline may not appear in a string, a string may not contain a null character or EOF 
******************************************************************************************************************
We have two functions to help us for strings.
checkLen checks the length of the of the string and returns true if
it is greater than the max length.
StrErr returns the error in the string and takes our state back to initial.
We use start conditions for strings as well. On encountering a " we begin string.
If we see another " we check for all the errors and if there are none we store the string in the table.
If we see EOF in the string we return ERROR.
If we see an escaped newline we just increment the line number.
If we see an unescaped newline we put up the error flag and continue parsing the string.
If we see the null character we put up the error flag and continue parsing the string.
If we see the characters \n,\t,\b,\f we put them into the string as it is.
If we see \c where c is not from above then we put c into the string without the \.
If we see anyother character we just check for length(to avoid memory leak)
and then store it in the string.

notes:
1) using echo \"'\\''\0'\" > null.cl, I made a 
file with an escaped null character,
a rule should be made for it,this would have
otherwise passed the test and entered the string.